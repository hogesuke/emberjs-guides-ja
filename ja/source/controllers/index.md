<!--
## Controllers
-->

## コントローラー

<!--
Controllers behave like a specialized type of Component that is rendered by
the router when entering a Route.
-->

コントローラーは、ルートに入るときにルータに描画される特殊なタイプのコンポーネントのように動作します。

<!--
The controller receives a single property from the Route – `model` – which is
the return value of the Route's `model()` method.
-->

コントローラーはRouteの`model()`メソッドの戻り値がプロパティ(`model`)に設定されます。

<!--
To define a Controller, run:
-->

コントローラを定義するには、次のコマンドを実行します。

```shell
ember generate controller my-controller-name
```

<!--
The value of `my-controller-name` must match the name of the Route that renders
it. So a Route named `blog-post` would have a matching Controller named
`blog-post`.
-->

`my-controller-name`の値は、それを描画するルートの名前と一致する必要があります。
したがって、`blog-post`という名前のルートには、`blog-post`という名前が一致したコントローラーを持つことになります。

<!--
You only need to generate a Controller if you want to customize its
properties or provide any `actions`. If you have no customizations, Ember will
provide a Controller instance for you at run time.
-->

プロパティをカスタマイズしたり、何らかの`action`を提供したい場合は、コントローラーを生成する必要があります。
コントローラーが生成にされていない場合は、Emberは実行時にコントローラーインスタンスを生成します。

<!--
Let's explore these concepts using an example of a route displaying a blog
post. Presume a `BlogPost` model that is presented in a `blog-post` template.
-->

ブログ記事を表示するルートの例を使って、これらの概念を詳しく見ていきましょう。
`blog-post`テンプレートに表示される`BlogPost`モデルがあるとします。

<!--
The `BlogPost` model would have properties like:
-->

`BlogPost`モデルは次のようなプロパティを持ちます。

* `title`
* `intro`
* `body`
* `author`

<!--
Your template would bind to these properties in the `blog-post`
template:
-->

`blog-post`テンプレートではこれらのプロパティを以下のようにバインドして使います。

```app/templates/blog-post.hbs
<h1>{{model.title}}</h1>
<h2>by {{model.author}}</h2>

<div class="intro">
  {{model.intro}}
</div>
<hr>
<div class="body">
  {{model.body}}
</div>
```

<!--
In this simple example, we don't have any display-specific properties
or actions just yet. For now, our controller's `model` property acts as a
pass-through (or "proxy") for the model properties. (Remember that
a controller gets the model it represents from its route handler.)
-->

このシンプルな例では、表示固有のプロパティやアクションはまだありません。
今のところ、コントローラの`model`プロパティは、modelのプロパティのパススルー(プロキシー)として機能します。
(コントローラのmodelプロパティはルートハンドラのmodelフックが返した値が設定さるのを覚えておきましょう)

<!--
Let's say we wanted to add a feature that would allow the user to
toggle the display of the body section. To implement this, we would
first modify our template to show the body only if the value of a
new `isExpanded` property is true.
-->

例えば、ユーザーが本文の表示を切り替えできる機能を追加したいとしましょう。
これを実装するには、`isExpanded`プロパティの値がtrueの場合にのみ本文を表示するようにテンプレートを修正します。

```app/templates/blog-post.hbs
<h1>{{model.title}}</h1>
<h2>by {{model.author}}</h2>

<div class='intro'>
  {{model.intro}}
</div>
<hr>

{{#if isExpanded}}
  <button {{action "toggleBody"}}>Hide Body</button>
  <div class="body">
    {{model.body}}
  </div>
{{else}}
  <button {{action "toggleBody"}}>Show Body</button>
{{/if}}
```

<!--
You can then define what the action does within the `actions` hook
of the controller, as you would with a component:
-->

次に、コンポーネントと同じように、コントローラーの`actions`フック内でアクションが何をするかを定義します。

```app/controllers/blog-post.js
import Controller from '@ember/controller';

export default Controller.extend({
  isExpanded: false,

  actions: {
    toggleBody() {
      this.toggleProperty('isExpanded');
    }
  }
});
```

<!--
### Common questions
-->

### よくある質問

<!--
<div class="common-question">
  <h4>Should I use controllers in my application? I've heard they're going away!</h4>
  
  <p>Yes! Controllers are still an integral part of an Ember application architecture, and generated by the framework even if you don't declare a Controller module explicitly.</p>
</div>
-->

<div class="common-question">
  <h4>コントローラーを使う必要はありますか？削除されると聞いたのですが</h4>
  
  <p>はい！コントローラーは今でもEmberアプリケーションアーキテクチャの不可欠な部分であり、コントローラーを明示的に宣言しなくてもフレームワークによって生成されます。</p>
</div>